HTTP 프로토콜이란 무엇인가?

 

HTTP는 웹에서 데이터를 전송하는데 주로 사용되는 프로토콜로, 클라이언트-서버 모델을 따릅니다. 상태를 유지하지 않는 특성 때문에 각 요청이 독립적으로 처리되며, 이는 성능적으로 유리합니다. 하지만 사용자 상태를 유지하는 웹 애플리케이션에서는 쿠키나 세션 같은 기술이 필요합니다. 기본적으로 암호화되지 않아 보안이 필요한 경우 HTTPS를 사용합니다.

 

클라이언트-서버 모델은 컴퓨터 네트워크에서 가장 일반적으로 사용되는 컴퓨팅 모델 중 하나입니다. 이 모델에서, 서버는 리소스와 서비스를 제공하며, 클라이언트는 서버에게 서비스를 요청하고 서버로부터 리소스를 소비합니다.

클라이언트: 클라이언트는 사용자가 직접 상호작용하는 컴퓨터 시스템입니다. 이는 웹 브라우저와 같은 소프트웨어를 사용하여 서버에 정보를 요청합니다. 클라이언트는 서버로부터 응답을 받아 처리하고, 사용자에게 결과를 표시합니다.
서버: 서버는 네트워크에 연결된 컴퓨터 시스템으로, 클라이언트의 요청에 응답하고 필요한 데이터나 서비스를 제공합니다. 이는 파일 서버, 웹 서버, 데이터베이스 서버 등 다양한 형태가 있을 수 있습니다.
통신: 클라이언트와 서버 사이의 통신은 일반적으로 요청-응답 모델을 사용합니다. 클라이언트가 서버에 요청을 보내면, 서버는 그 요청을 처리하고 결과를 클라이언트에게 전송합니다. 이러한 통신은 HTTP와 같은 프로토콜을 사용하여 진행됩니다.
이러한 클라이언트-서버 모델은 컴퓨터 시스템이 서로 다른 역할을 하도록 분리되어 있기 때문에, 각 시스템은 자신의 역할에 최적화된 하드웨어와 소프트웨어를 사용할 수 있습니다. 또한, 이 모델을 사용하면 서버가 처리할 수 있는 클라이언트의 수를 쉽게 확장할 수 있으므로, 대규모 서비스를 제공하는 데 이상적입니다.

 

"상태를 유지하지 않는다"는 말은 특정 연결이나 세션에 대해 이전의 요청이나 행동에 대한 정보를 저장하거나 유지하지 않는다는 것을 의미합니다.

예를 들어 HTTP와 같은 무상태 프로토콜에서, 각 요청은 독립적으로 처리되고 그 이전의 요청이나 그 결과에 대한 정보는 저장되지 않습니다. 즉, 각각의 요청이 서로 독립적으로 실행됩니다.

이러한 무상태성은 간결성과 효율성을 제공하지만, 사용자의 세션을 관리하거나 이전의 상태에 따라 동작을 변경해야 하는 경우에는 문제가 될 수 있습니다. 예를 들어, 사용자가 웹사이트에 로그인한 상태를 유지하려면, 해당 정보를 어딘가에 저장해야 하는데, 이를 위해 종종 쿠키나 세션 같은 기술을 사용하여 상태를 유지합니다. 이렇게 해서 HTTP와 같은 무상태 프로토콜 위에서 상태를 유지할 수 있게 됩니다.

 

HTTP의 요청/응답 모델을 설명한다면?

 

HTTP의 요청/응답 모델은 클라이언트-서버 간의 상호작용을 정의하는 중요한 컴포넌트입니다. 클라이언트(대개 웹 브라우저)는 HTTP 요청을 서버로 보내고, 서버는 이 요청을 처리하여 HTTP 응답을 클라이언트로 보냅니다. 요청은 주로 웹 페이지나 API 리소스에 대한 데이터를 요청하며, HTTP 메서드(GET, POST, PUT, DELETE 등)와 함께 URL, 헤더, 요청 본문을 포함할 수 있습니다. 응답은 서버에서 처리된 결과를 클라이언트에게 전달하며, 상태 코드(200, 404, 500 등), 헤더, 응답 본문을 포함합니다. 상태 코드는 요청의 성공, 실패 여부와 그 이유를 알려주는데 사용됩니다.

 

HTTP 메서드 중 GET과 POST의 차이점은?

 

HTTP 프로토콜의 주요 메서드인 GET과 POST는 다음과 같습니다:

GET: 서버로부터 정보를 요청하는 메서드로, 동일한 요청이 여러 번 실행되어도 서버의 상태에 변화를 주지 않습니다. 따라서 안전하며 멱등성을 지닙니다. 브라우저의 기록에 남아 캐싱이 가능하므로 속도적 이점이 있습니다.
POST: 클라이언트가 서버의 리소스를 새로 생성하거나 변경하도록 요청하는 메서드로, 이는 서버의 상태를 변경하므로 일반적으로 비멱등성을 가집니다. 이로 인해 브라우저 기록에 남지 않으며 캐시할 수 없습니다.
따라서, GET은 정보를 읽어오는데 사용하며, POST는 정보를 생성하거나 변경하는데 사용하는 것이 적합합니다. 이 둘을 적절히 사용하면 네트워크 효율성과 데이터 무결성을 보장할 수 있습니다.

 

캐싱이 가능하다는 것은 특정 정보를 임시로 저장해두어 나중에 같은 요청이 오면 원래의 소스(예를 들어, 서버)에 다시 접근하지 않고도 그 정보를 제공할 수 있다는 의미입니다. 이는 네트워크 트래픽을 줄이고 응답 시간을 개선하는 효과가 있습니다.

예를 들어, 웹 브라우저는 사용자가 방문한 웹 페이지의 내용을 캐시에 저장할 수 있습니다. 사용자가 동일한 웹 페이지를 다시 방문하면, 브라우저는 캐시에 저장된 정보를 사용하여 빠르게 페이지를 로드할 수 있습니다.

반대로 "캐시할 수 없다"는 것은 해당 정보를 임시로 저장하더라도 다음에 같은 요청이 오면 캐시에 저장된 정보를 사용하지 않고 원래의 소스에 다시 접근해야 한다는 것을 의미합니다. 이는 정보가 자주 변경되거나 중요한 정보에 대해 최신 상태를 유지해야 할 경우에 주로 사용됩니다.

 

예를 들어, 인터넷 뱅킹에서 계좌 잔액 정보와 같은 데이터는 매번 실시간으로 갱신되어야 하므로 이런 정보를 캐시에 저장하는 것은 적합하지 않습니다. 이런 경우, 데이터를 요청할 때마다 서버에 접근해 최신 정보를 가져옵니다.

 

GET 요청은 멱등성을 가집니다. 멱등성이란 같은 요청을 여러 번 전송하더라도 동일한 결과를 반환한다는 의미입니다. 이는 정보를 조회하는데 사용되는 만큼, 동일한 GET 요청을 여러 번 해도 서버 상태가 변경되지 않기 때문입니다.

 

POST 요청은 멱등성이 없습니다. 같은 POST 요청을 여러 번 보내면 서버에는 새로운 리소스가 여러 번 생성되기 때문입니다.

 

GET과 POST의 가장 큰 차이점은 GET이 서버로부터 정보를 조회하고, POST가 서버에 새로운 정보를 추가한다는 점과, 그에 따른 멱등성의 유무입니다. 이 두 가지 메서드를 올바르게 사용하는 것은 웹 애플리케이션의 효율성과 안정성을 크게 향상시키는 요소입니다

 

HTTP 메서드 중 PUT과 PATCH의 차이점은?

 

HTTP 프로토콜의 두 주요 메서드인 PUT과 PATCH는 다음과 같이 구분됩니다:

PUT은 서버의 리소스를 완전히 대체하는 메서드입니다. PUT 요청은 항상 동일한 결과를 반환해야하므로 멱등성을 가집니다. 즉, 동일한 PUT 요청을 여러 번 보내도 동일한 결과가 나와야합니다.
PATCH는 서버의 리소스를 부분적으로 수정하는 메서드입니다. PATCH 요청은 요청에 따라 결과가 달라질 수 있으므로 비멱등성을 가집니다. PATCH는 리소스의 일부만 수정하므로 리소스 전체를 업로드 할 필요가 없어 네트워크 효율성이 향상될 수 있습니다.
HTTP 메서드인 PUT과 PATCH는 서버 상의 데이터를 갱신하기 위한 목적으로 사용되지만, 그 작동 방식에 차이가 있습니다.

PUT 메서드는 서버 상의 특정 리소스를 새로운 것으로 완전히 대체하는 데 사용됩니다. 예를 들어, 기존에 저장된 사용자 프로필 데이터를 새로운 사용자 프로필 데이터로 완전히 대체하고 싶을 때 사용합니다. 이런 경우, PUT 요청은 모든 필드 정보를 포함해야 합니다.

반면에, PATCH 메서드는 서버 상의 특정 리소스를 부분적으로 수정하는 데 사용됩니다. 예를 들어, 사용자 프로필의 특정 부분, 예를 들어 이메일 주소나 전화번호 등만 수정하고 싶을 때 PATCH 요청을 사용할 수 있습니다. 이런 경우, PATCH 요청은 변경하고자 하는 필드 정보만 포함하면 됩니다.

즉, PUT은 전체 리소스를 대체하는 반면, PATCH는 리소스의 일부만을 변경하는 역할을 합니다. 이 둘의 차이점을 이해하는 것은 중요합니다, 왜냐하면 잘못된 메서드를 사용하면 의도치 않은 데이터 손실이 발생할 수 있기 때문입니다.

 

HTTP 메서드인 PUT과 PATCH의 차이를 이해하지 못하면 의도치 않은 데이터 손실이 발생할 수 있습니다. 이를 설명하는 가장 좋은 예시는 다음과 같습니다:

예를 들어, 서버에 저장된 사용자 프로필 정보가 다음과 같다고 가정합시다.

{
  "name": "John Doe",
  "email": "john@doe.com",
  "phone": "123-456-7890"
}

여기서 사용자의 이메일만 변경하고 싶어서 PUT 요청을 보내는데, 다음과 같이 이메일 정보만을 담고 있습니다:

PUT /user/1
{
  "email": "john@new.com"
}

PUT 메서드의 특성상, 이 요청은 사용자 프로필의 모든 정보를 이메일로만 대체하려고 합니다. 그래서, 요청 후에 사용자 프로필은 다음과 같이 변하게 됩니다:

{
  "email": "john@new.com"
}

이 경우, 사용자의 이름(name)과 전화번호(phone) 정보가 삭제되었습니다. 이것이 의도치 않은 데이터 손실의 예시입니다.

이를 방지하려면, PATCH 요청을 사용해야 합니다. PATCH 요청은 리소스의 일부만 수정하므로, 다음과 같은 요청은 이메일만 수정하고 나머지 정보를 그대로 유지하게 됩니다:

PATCH /user/1
{
  "email": "john@new.com"
}

이에 따라, 의도한 대로 이메일만 변경되고, 이름과 전화번호는 그대로 유지됩니다. 따라서, HTTP 메서드를 올바르게 사용하는 것이 중요합니다.

 

HTTP 상태 코드는 무엇인가?

 

HTTP 상태 코드는 서버의 응답 상태를 나타내는 3자리 숫자로, 요청 처리의 성공, 리다이렉션, 클라이언트/서버 오류 등을 구분합니다. 대표적으로 200은 요청 성공, 404는 클라이언트 오류인 'Not Found', 500은 서버 오류인 'Internal Server Error'를 의미합니다. 이들 코드를 이해하고 사용하면 통신의 명확성이 증가하고, 에러 처리 및 디버깅이 용이해집니다.

 

HTTP 상태 코드는 서버가 클라이언트의 요청에 대해 응답하는 방식을 나타냅니다. 상태 코드는 주로 3자리 숫자로 표시되며, 각각의 숫자는 응답의 종류를 나타냅니다. 대표적인 HTTP 상태 코드는 다음과 같습니다:

2xx (성공): 요청이 성공적으로 처리되었음을 나타냅니다. 예를 들어, 200은 OK를 의미하며, 서버가 요청을 성공적으로 처리했음을 나타냅니다.
3xx (리다이렉션): 클라이언트가 요청을 완료하기 위해 추가 조치를 취해야 함을 나타냅니다. 예를 들어, 301은 Permanent Redirect를 의미하며, 요청한 리소스가 영구적으로 새 위치로 이동했음을 나타냅니다.
4xx (클라이언트 오류): 클라이언트 요청에 오류가 있음을 나타냅니다. 예를 들어, 404는 Not Found를 의미하며, 요청한 리소스를 서버에서 찾을 수 없음을 나타냅니다.
5xx (서버 오류): 서버가 요청을 처리하는 데 실패했음을 나타냅니다. 예를 들어, 500은 Internal Server Error를 의미하며, 서버 내부 오류로 인해 요청을 처리할 수 없음을 나타냅니다.
이러한 HTTP 상태 코드를 이해하고 사용하는 것은 클라이언트와 서버 간의 통신을 명확하게 이해하고, 적절한 에러 처리 및 디버깅을 수행하는 데 도움이 됩니다.

 

HTTP 헤더란 무엇인가?

 

HTTP 헤더는 요청과 응답에서 메타데이터를 교환하는 중요한 방법입니다. 예를 들어 'User-Agent' 요청 헤더는 클라이언트의 종류와 버전을 알려주고, 'Accept' 요청 헤더는 클라이언트가 처리할 수 있는 미디어 유형을 지정합니다. 반대로 'Server' 응답 헤더는 서버의 정보를 제공하고, 'Content-Encoding' 응답 헤더는 페이로드의 인코딩을 나타냅니다. 이런 헤더들은 웹 브라우저, 웹 서버, API 등이 효율적으로 소통하도록 도와줍니다.

 

메타데이터(metadata)는 데이터에 대한 데이터로, 다른 데이터를 설명하거나 분류하는데 사용됩니다. 간단히 말해, 데이터의 데이터라고 할 수 있습니다. 메타데이터는 데이터의 의미, 관계, 출처, 위치 등 다양한 정보를 제공하여 데이터 자체를 더 잘 이해하고 효율적으로 활용할 수 있게 돕습니다. 예를 들어, 디지털 사진의 메타데이터는 촬영 날짜, 위치, 카메라 모델 등을 포함할 수 있습니다.

 

HTTP 헤더는 주로 네트워크 상에서 클라이언트와 서버, 또는 다른 네트워크 장치들이 통신할 때 필요한 정보를 교환하기 위한 목적으로 사용됩니다. 이는 헤더가 요청이나 응답의 세부사항, 특성, 상태 등에 대한 정보를 제공하므로, 이를 통해 장치들이 상호작용을 적절하게 처리할 수 있습니다.

 

그러나 개발자의 관점에서 보면, HTTP 헤더를 이해하고 활용하는 것은 웹 서비스를 개발하고, 문제를 디버깅하고, 서비스의 성능을 최적화하는 등에 있어 매우 중요한 역할을 합니다. 따라서 HTTP 헤더는 네트워크 장치 간의 통신뿐만 아니라, 사람이 코드를 이해하고 작성하는데도 큰 도움을 줍니다.

 

모든 웹 기술들은 HTTP 프로토콜을 기반으로 통신하므로 Java(Spring Boot)나 JavaScript(Node.js) 등 어떤 웹 어플리케이션에서든 HTTP 헤더를 사용하여 메타데이터를 전송하고 받습니다.

예를 들어, Spring Boot에서는 @RequestHeader 어노테이션을 사용하여 요청 헤더에 접근할 수 있습니다.

@RequestMapping(value = "/example", method = RequestMethod.GET)
public String example(@RequestHeader("User-Agent") String userAgent) {
    // 이제 userAgent는 "User-Agent" 헤더의 값을 가집니다.
    ...
}

JavaScript (특히 Node.js)에서는 Express.js 프레임워크를 사용하면 HTTP 헤더에 쉽게 접근할 수 있습니다.

app.get('/example', function (req, res) {
  var userAgent = req.headers['user-agent'];
  // 이제 userAgent는 "User-Agent" 헤더의 값을 가집니다.
  ...
});

또한 HTTP 응답 헤더를 설정하는 경우도 마찬가지로, Spring Boot나 Express.js에서 제공하는 메서드를 사용하여 응답 헤더를 설정할 수 있습니다. 이러한 방식으로, 웹 애플리케이션은 HTTP 요청과 응답에서 메타데이터를 읽고 쓸 수 있습니다.

 

어노테이션은 메타데이터를 제공하는 자바의 기능입니다. 어노테이션이 없어도 자바 코드는 작동합니다. 그러나 어노테이션은 프레임워크나 컴파일러에게 코드가 어떻게 작동해야 하는지에 대한 추가적인 정보를 제공합니다. 이 정보는 실행 중에나 컴파일 시점에 해석되고 활용됩니다.

 

예를 들어, Spring Boot에서 @RequestHeader 어노테이션은 HTTP 요청 헤더에서 특정 값을 가져와 메서드 매개변수에 바인딩해주는 역할을 합니다. 이 어노테이션을 사용하지 않는다면, 직접적으로 HTTP 요청 객체에 접근하고, 해당 헤더를 찾아 값을 추출하는 등의 작업을 수동으로 해야 합니다.

따라서 어노테이션의 유무는 코드의 작동 여부에 직접적인 영향을 주지 않지만, 개발자가 직접 처리해야 할 로직을 효과적으로 간소화해주며, 코드의 가독성과 유지보수성을 높이는 데 도움이 됩니다.

 

HTTP의 무상태성 (Stateless)란 무엇인가?

 

HTTP의 "무상태성(stateless)"은 HTTP 프로토콜이 각 요청을 별개의 트랜잭션으로 처리하며, 이전 요청에 대한 정보를 기억하지 않는 특성을 의미합니다. 즉, 클라이언트가 서버에 요청을 보내고 서버가 응답을 보낸 후에는, 서버는 클라이언트에 대한 어떤 정보도 유지하지 않습니다. 이러한 무상태성은 웹의 확장성을 향상시키는데 기여하지만, 동시에 세션 관리 등 클라이언트의 상태를 유지해야하는 상황에는 별도의 방법이 필요하게 합니다.

 

"별개의 트랜잭션으로 처리한다"는 말은, 각각의 HTTP 요청과 응답 쌍이 서로 독립적이라는 것을 의미합니다. 이는 HTTP의 무상태성(statelessness) 특성과 관련이 있습니다.

HTTP가 무상태 프로토콜이라는 것은, 한 번의 요청과 응답을 주고받은 후, 서버는 클라이언트에 대한 어떤 상태 정보도 기억하지 않는다는 것입니다. 즉, 각각의 요청은 이전 요청이나 다음 요청과 전혀 관련이 없는, 독립적인 트랜잭션입니다.

예를 들어, 웹 브라우저를 통해 웹 페이지를 둘러보는 사용자가 있을 때, 사용자가 웹 페이지의 'A' 링크를 클릭하면 웹 브라우저는 서버에 'A' 페이지에 대한 HTTP 요청을 보냅니다. 서버는 이 요청에 대한 응답을 보내고 나면, 이 사용자에 대한 정보를 기억하지 않습니다. 이후 사용자가 'B' 링크를 클릭하면 새로운 HTTP 요청이 발생하지만, 이 요청은 앞서 'A' 링크에 대한 요청과 완전히 독립적인 트랜잭션입니다. 즉, 서버는 'B' 링크 요청이 'A' 링크 요청 후에 발생한 것임을 알 수 없습니다.

이런 특성은 웹의 확장성을 높여주지만, 사용자의 상태를 유지하거나 이전 요청에 따라 다음 요청을 처리해야 하는 경우에는 세션, 쿠키 등의 기술이 필요합니다.

 

Transaction : 거래

 

HTTP Keep-Alive란 무엇인가?

 

HTTP Keep-Alive는 하나의 TCP 연결을 여러 HTTP 요청/응답에 재사용하여 네트워크 지연 시간을 줄이고 리소스 사용을 효율화하는 메커니즘입니다. 기본적으로 HTTP/1.1에서는 Keep-Alive가 활성화 되어 있으며, 이를 통해 연결 설정과 해제로 인한 오버헤드를 감소시키고 전반적인 웹 성능을 향상시킵니다. HTTP/1.0에서는 클라이언트가 명시적으로 'Connection: keep-alive' 헤더를 보내야 합니다.